# Backtesting Engine Migration - Requirements Document

## Introduction

The Backtesting Engine Migration project aims to replace the existing Python-based backtesting framework (from `/home/raja/code/money-plant-python/back_testing`) with a high-performance Java-based system. The current Python implementation processes 2000 symbols in 4 minutes using parallel processing, with 2-5 seconds per symbol. The new Java engine targets 10-20x performance improvement, achieving backtesting of 2000+ symbols in under 1 minute with <100ms per symbol processing time.

Built as a Spring Boot modulith within the existing `./engines` architecture, this engine will leverage TA4J for technical indicators, Apache Spark for distributed processing, and implement the Adaptive Accumulation Strategy (AAS) pattern from the Python codebase. The system will support multiple concurrent strategies, parameter optimization, and comprehensive performance metrics calculation.

This specification addresses Phase 2 of the Python-to-Java migration, focusing on strategy backtesting, performance analysis, and optimization capabilities for quantitative trading.

## Glossary

- **Backtesting_Engine**: Java-based system for simulating trading strategies on historical data
- **Strategy**: Trading algorithm with entry/exit rules and position management logic
- **AAS**: Adaptive Accumulation Strategy - existing Python strategy to be ported to Java
- **TA4J**: Technical Analysis for Java - library for calculating technical indicators
- **Indicator**: Mathematical calculation on price/volume data (RSI, MACD, SMA, etc.)
- **Signal**: Trading signal generated by strategy (BUY, SELL, HOLD)
- **Position**: Open trade with entry price, quantity, and current P&L
- **Backtest_Run**: Single execution of strategy on historical data with specific parameters
- **Performance_Metrics**: Statistical measures of strategy performance (Sharpe, Sortino, drawdown, etc.)
- **Parameter_Optimization**: Process of finding optimal strategy parameters through grid search or genetic algorithms
- **Trade**: Completed transaction with entry, exit, P&L, and duration
- **Equity_Curve**: Time series of portfolio value over backtest period
- **Slippage**: Difference between expected and actual execution price
- **Commission**: Transaction cost for buying/selling securities
- **Walk_Forward_Analysis**: Validation technique using rolling training and testing periods

## Requirements

### Requirement 1: Strategy Framework and Abstract Pattern

**User Story:** As a quantitative developer, I want an abstract strategy framework similar to the Python implementation, so that I can implement multiple trading strategies with consistent interfaces.

#### Acceptance Criteria

1. WHEN Strategy is defined THEN the Backtesting_Engine SHALL provide abstract base class with initialize, onBar, onTick, and finalize methods
2. WHEN Strategy is implemented THEN it SHALL support configurable parameters with type safety and validation
3. WHEN multiple strategies are registered THEN the Backtesting_Engine SHALL maintain strategy registry with metadata
4. WHEN Strategy lifecycle is managed THEN the Backtesting_Engine SHALL call initialize before backtest and finalize after completion
5. WHEN Strategy state is maintained THEN it SHALL use immutable data structures for thread-safety
6. WHEN Strategy generates Signal THEN it SHALL return BUY, SELL, or HOLD with optional quantity and price limits
7. WHEN Strategy accesses market data THEN it SHALL use time-series API preventing look-ahead bias
8. WHEN Strategy is validated THEN the Backtesting_Engine SHALL check for common errors (future data access, infinite loops)

### Requirement 2: AAS Strategy Port from Python

**User Story:** As a trader, I want the Adaptive Accumulation Strategy ported from Python to Java, so that I can continue using proven strategies with improved performance.

#### Acceptance Criteria

1. WHEN AAS Strategy is implemented THEN it SHALL replicate exact logic from Python implementation including entry/exit rules
2. WHEN accumulation phase is active THEN the Strategy SHALL buy on dips with configurable accumulation percentage
3. WHEN exit conditions are met THEN the Strategy SHALL sell positions based on profit targets or stop-loss levels
4. WHEN position sizing is calculated THEN the Strategy SHALL use risk-based position sizing with maximum position limits
5. WHEN indicators are used THEN the Strategy SHALL calculate RSI, MACD, and moving averages using TA4J library
6. WHEN strategy parameters are configured THEN it SHALL support RSI period, MACD parameters, accumulation threshold, and profit target
7. WHEN backtesting completes THEN the Strategy SHALL produce identical results to Python implementation for validation dataset
8. WHEN performance is measured THEN the Java implementation SHALL execute 10-20x faster than Python version

### Requirement 3: TA4J Technical Indicators Integration

**User Story:** As a strategy developer, I want comprehensive technical indicators library, so that I can build sophisticated trading strategies.

#### Acceptance Criteria

1. WHEN indicators are calculated THEN the Backtesting_Engine SHALL use TA4J for RSI, MACD, Bollinger Bands, ATR, and moving averages
2. WHEN custom indicators are needed THEN the Backtesting_Engine SHALL support user-defined indicator implementations
3. WHEN indicator values are accessed THEN it SHALL provide time-series API with getValue(index) and getLatest() methods
4. WHEN indicator caching is enabled THEN the Backtesting_Engine SHALL cache calculated values to avoid recomputation
5. WHEN indicator parameters are changed THEN it SHALL invalidate cache and recalculate values
6. WHEN multiple timeframes are used THEN the Backtesting_Engine SHALL support indicator calculation on different timeframes
7. WHEN indicator validation occurs THEN it SHALL check for sufficient data points before calculation
8. WHEN performance is optimized THEN indicator calculations SHALL complete in <1ms per bar

### Requirement 4: High-Performance Backtesting Execution

**User Story:** As a quantitative analyst, I want ultra-fast backtesting execution, so that I can iterate quickly on strategy development and optimization.

#### Acceptance Criteria

1. WHEN single symbol backtest runs THEN the Backtesting_Engine SHALL complete in <100ms for 1 year of daily data
2. WHEN multiple symbols are backtested THEN the Backtesting_Engine SHALL process 2000+ symbols in <60 seconds using parallel execution
3. WHEN parallel processing is used THEN it SHALL leverage Java 21 virtual threads for lightweight concurrency
4. WHEN memory is managed THEN the Backtesting_Engine SHALL use off-heap memory for large datasets to avoid GC pressure
5. WHEN data is loaded THEN it SHALL use memory-mapped files for fast historical data access
6. WHEN execution is optimized THEN the Backtesting_Engine SHALL use JIT compilation and avoid boxing/unboxing overhead
7. WHEN batch processing occurs THEN it SHALL process multiple strategies on same data in single pass
8. WHEN progress is tracked THEN the Backtesting_Engine SHALL report progress percentage and estimated completion time

### Requirement 5: Position and Trade Management

**User Story:** As a backtesting system, I want accurate position tracking and trade recording, so that I can calculate precise performance metrics.

#### Acceptance Criteria

1. WHEN Position is opened THEN the Backtesting_Engine SHALL record entry price, quantity, timestamp, and strategy identifier
2. WHEN Position is closed THEN it SHALL calculate realized P&L including Commission and Slippage
3. WHEN multiple positions exist THEN the Backtesting_Engine SHALL support FIFO, LIFO, and average cost accounting methods
4. WHEN Trade is completed THEN it SHALL record entry/exit prices, quantity, duration, P&L, and return percentage
5. WHEN position limits are enforced THEN the Backtesting_Engine SHALL prevent exceeding maximum position size or portfolio exposure
6. WHEN margin is calculated THEN it SHALL track available capital and prevent over-leveraging
7. WHEN corporate actions occur THEN the Backtesting_Engine SHALL adjust positions for splits and dividends
8. WHEN trade history is queried THEN it SHALL provide filtering by symbol, date range, and strategy

### Requirement 6: Performance Metrics Calculation

**User Story:** As a portfolio manager, I want comprehensive performance metrics, so that I can evaluate and compare trading strategies objectively.

#### Acceptance Criteria

1. WHEN backtest completes THEN the Backtesting_Engine SHALL calculate total return, annualized return, and CAGR
2. WHEN risk metrics are computed THEN it SHALL calculate Sharpe ratio, Sortino ratio, and Calmar ratio
3. WHEN drawdown analysis is performed THEN it SHALL calculate maximum drawdown, average drawdown, and drawdown duration
4. WHEN win rate is calculated THEN it SHALL compute percentage of winning trades and profit factor
5. WHEN volatility is measured THEN it SHALL calculate annualized volatility and beta against benchmark
6. WHEN trade statistics are generated THEN it SHALL provide average trade duration, average win/loss, and largest win/loss
7. WHEN benchmark comparison is enabled THEN it SHALL calculate alpha, tracking error, and information ratio
8. WHEN metrics are exported THEN the Backtesting_Engine SHALL generate JSON and CSV reports with all metrics

### Requirement 7: Parameter Optimization Framework

**User Story:** As a quantitative researcher, I want automated parameter optimization, so that I can find optimal strategy parameters efficiently.

#### Acceptance Criteria

1. WHEN grid search is initiated THEN the Backtesting_Engine SHALL test all parameter combinations within specified ranges
2. WHEN genetic algorithm is used THEN it SHALL evolve parameter sets over multiple generations with fitness function
3. WHEN optimization objective is set THEN it SHALL support maximizing Sharpe ratio, return, or custom objective function
4. WHEN overfitting is prevented THEN the Backtesting_Engine SHALL use train/test split or Walk_Forward_Analysis
5. WHEN parallel optimization runs THEN it SHALL distribute parameter combinations across available CPU cores
6. WHEN optimization completes THEN it SHALL rank parameter sets by objective function and provide top N results
7. WHEN optimization progress is tracked THEN it SHALL report completed iterations and best result so far
8. WHEN results are visualized THEN the Backtesting_Engine SHALL generate parameter sensitivity heatmaps

### Requirement 8: Apache Spark Integration for Distributed Processing

**User Story:** As a data engineer, I want Spark integration for processing large-scale backtests, so that I can scale beyond single-machine limitations.

#### Acceptance Criteria

1. WHEN Spark is enabled THEN the Backtesting_Engine SHALL distribute symbol backtests across Spark cluster
2. WHEN data is partitioned THEN it SHALL partition by symbol for parallel processing
3. WHEN Spark job is submitted THEN it SHALL use Spark 3.x with Java API for distributed execution
4. WHEN results are aggregated THEN it SHALL collect individual backtest results and compute portfolio-level metrics
5. WHEN Spark resources are configured THEN it SHALL support configurable executor memory, cores, and parallelism
6. WHEN fault tolerance is implemented THEN it SHALL handle executor failures with automatic retry
7. WHEN Spark UI is accessed THEN it SHALL provide job monitoring and performance metrics
8. WHEN local mode is used THEN the Backtesting_Engine SHALL support Spark local mode for development

### Requirement 9: Slippage and Commission Modeling

**User Story:** As a realistic backtester, I want accurate slippage and commission modeling, so that backtest results reflect real-world trading costs.

#### Acceptance Criteria

1. WHEN Commission is calculated THEN the Backtesting_Engine SHALL support fixed per-trade, percentage-based, and tiered commission structures
2. WHEN Slippage is modeled THEN it SHALL support fixed slippage, percentage slippage, and volume-based slippage models
3. WHEN market impact is considered THEN it SHALL adjust slippage based on order size relative to average volume
4. WHEN bid-ask spread is included THEN the Backtesting_Engine SHALL apply spread cost to all trades
5. WHEN commission schedules are configured THEN it SHALL support broker-specific commission structures (Zerodha, ICICI, etc.)
6. WHEN costs are reported THEN it SHALL break down total costs by commission, slippage, and spread
7. WHEN cost optimization is analyzed THEN it SHALL show impact of different cost assumptions on strategy performance
8. WHEN realistic execution is simulated THEN the Backtesting_Engine SHALL prevent trades during market close or circuit breakers

### Requirement 10: Event-Driven Backtesting Architecture

**User Story:** As a system architect, I want event-driven architecture, so that backtesting closely mimics real-time trading execution.

#### Acceptance Criteria

1. WHEN backtest runs THEN the Backtesting_Engine SHALL process market data events in chronological order
2. WHEN events are dispatched THEN it SHALL support bar events, tick events, and order events
3. WHEN event handlers are registered THEN Strategy SHALL subscribe to specific event types
4. WHEN event processing occurs THEN it SHALL ensure no look-ahead bias by processing events sequentially
5. WHEN order execution is simulated THEN it SHALL generate order fill events with realistic timing
6. WHEN event queue is managed THEN the Backtesting_Engine SHALL use priority queue for event ordering
7. WHEN event replay is enabled THEN it SHALL support replaying historical events for debugging
8. WHEN event logging is configured THEN it SHALL log all events for audit trail and analysis

### Requirement 11: Multi-Strategy Portfolio Backtesting

**User Story:** As a portfolio manager, I want to backtest multiple strategies simultaneously, so that I can evaluate portfolio-level performance and diversification benefits.

#### Acceptance Criteria

1. WHEN multiple strategies are backtested THEN the Backtesting_Engine SHALL run strategies concurrently on same data
2. WHEN capital allocation is configured THEN it SHALL allocate capital across strategies based on weights or risk parity
3. WHEN portfolio rebalancing occurs THEN it SHALL support periodic rebalancing with configurable frequency
4. WHEN correlation is analyzed THEN the Backtesting_Engine SHALL calculate strategy correlation matrix
5. WHEN portfolio metrics are computed THEN it SHALL calculate portfolio-level Sharpe ratio, drawdown, and return
6. WHEN strategy contribution is measured THEN it SHALL attribute portfolio performance to individual strategies
7. WHEN risk limits are enforced THEN it SHALL prevent portfolio from exceeding maximum drawdown or volatility targets
8. WHEN portfolio optimization is performed THEN the Backtesting_Engine SHALL find optimal strategy weights

### Requirement 12: Backtesting Results Storage and Retrieval

**User Story:** As a quantitative analyst, I want to store and retrieve backtest results, so that I can compare strategies and track performance over time.

#### Acceptance Criteria

1. WHEN backtest completes THEN the Backtesting_Engine SHALL persist results to PostgreSQL with unique run identifier
2. WHEN results are stored THEN it SHALL save strategy parameters, Performance_Metrics, Trade history, and Equity_Curve
3. WHEN results are queried THEN it SHALL support filtering by strategy name, date range, and performance criteria
4. WHEN comparison is needed THEN the Backtesting_Engine SHALL retrieve multiple backtest runs for side-by-side comparison
5. WHEN versioning is enabled THEN it SHALL track strategy code versions and associate with backtest runs
6. WHEN data retention is configured THEN it SHALL implement retention policies for old backtest results
7. WHEN export is requested THEN the Backtesting_Engine SHALL export results to CSV, JSON, and Excel formats
8. WHEN visualization is generated THEN it SHALL create equity curve charts, drawdown charts, and trade distribution plots

### Requirement 13: Real-time Backtesting Monitoring

**User Story:** As a DevOps engineer, I want real-time monitoring of backtesting jobs, so that I can track progress and identify performance bottlenecks.

#### Acceptance Criteria

1. WHEN backtest is running THEN the Backtesting_Engine SHALL expose progress metrics via Prometheus endpoint
2. WHEN metrics are collected THEN it SHALL track symbols processed, trades executed, and processing rate
3. WHEN performance is monitored THEN it SHALL measure CPU usage, memory usage, and GC activity
4. WHEN bottlenecks are identified THEN it SHALL provide profiling data for slow operations
5. WHEN alerts are configured THEN it SHALL trigger alerts for long-running jobs or failures
6. WHEN dashboards are created THEN it SHALL provide Grafana dashboard templates for backtest monitoring
7. WHEN logs are generated THEN it SHALL use structured logging with backtest run ID for correlation
8. WHEN health checks run THEN the Backtesting_Engine SHALL implement health indicators for database and data access

### Requirement 14: Walk-Forward Analysis and Validation

**User Story:** As a quantitative researcher, I want walk-forward analysis, so that I can validate strategy robustness and avoid overfitting.

#### Acceptance Criteria

1. WHEN Walk_Forward_Analysis is configured THEN the Backtesting_Engine SHALL divide data into rolling training and testing windows
2. WHEN optimization is performed THEN it SHALL optimize parameters on training window and test on out-of-sample window
3. WHEN windows are rolled THEN it SHALL advance windows by configurable step size (e.g., 1 month)
4. WHEN results are aggregated THEN it SHALL combine out-of-sample results for overall performance assessment
5. WHEN overfitting is detected THEN it SHALL flag strategies with large in-sample vs out-of-sample performance gap
6. WHEN validation metrics are calculated THEN it SHALL compute consistency score across walk-forward windows
7. WHEN visualization is generated THEN the Backtesting_Engine SHALL plot in-sample vs out-of-sample equity curves
8. WHEN robustness is tested THEN it SHALL perform Monte Carlo simulation with parameter perturbation

### Requirement 15: Integration with Market Data Engine

**User Story:** As a system integrator, I want seamless integration with the Market Data Ingestion Engine, so that backtesting uses the same data as live trading.

#### Acceptance Criteria

1. WHEN historical data is needed THEN the Backtesting_Engine SHALL query TimescaleDB for OHLCV data
2. WHEN data is cached THEN it SHALL use Redis for frequently accessed historical data with 1-hour TTL
3. WHEN data gaps are detected THEN it SHALL request backfill from Market Data Engine
4. WHEN data quality is verified THEN it SHALL validate data completeness and consistency before backtesting
5. WHEN symbol metadata is required THEN it SHALL fetch from Market Data Engine symbol universe
6. WHEN data format is standardized THEN it SHALL use same data schema as Market Data Engine
7. WHEN data is updated THEN the Backtesting_Engine SHALL invalidate cache and reload updated data
8. WHEN API is used THEN it SHALL call Market Data Engine REST API for data retrieval with retry logic
