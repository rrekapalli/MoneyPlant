import { Injectable } from '@angular/core';
import * as XLSX from 'xlsx';
import { IWidget } from '../entities/IWidget';
import { WidgetDataExtractor } from '../widgets/widget/widget-builder';
import { 
  PieChartBuilder, 
  BarChartBuilder, 
  LineChartBuilder, 
  ScatterChartBuilder, 
  GaugeChartBuilder, 
  HeatmapChartBuilder, 
  DensityMapBuilder 
} from '../chart-builders';

export interface ExcelExportOptions {
  filename?: string;
  includeHeaders?: boolean;
  includeTimestamp?: boolean;
  sheetNamePrefix?: string;
  autoColumnWidth?: boolean;
  includeWidgetTitles?: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class ExcelExportService {

  /**
   * Export dashboard data to Excel
   * @param widgets - Array of widgets to export
   * @param options - Excel export options
   */
  async exportDashboardToExcel(
    widgets: IWidget[],
    options: ExcelExportOptions = {}
  ): Promise<void> {
    const {
      filename = `dashboard-export-${new Date().toISOString().split('T')[0]}.xlsx`,
      includeHeaders = true,
      includeTimestamp = true,
      sheetNamePrefix = 'Widget',
      autoColumnWidth = true,
      includeWidgetTitles = true
    } = options;

    try {
      console.log('Starting Excel export...');
      console.log(`Exporting ${widgets.length} widgets to Excel`);

      // Create a new workbook
      const workbook = XLSX.utils.book_new();

      // Add timestamp sheet if requested
      if (includeTimestamp) {
        this.addTimestampSheet(workbook);
      }

      // Export each widget to its own sheet
      for (const widget of widgets) {
        try {
          await this.exportWidgetToSheet(workbook, widget, {
            includeHeaders,
            sheetNamePrefix,
            autoColumnWidth,
            includeWidgetTitles
          });
        } catch (error) {
          console.error(`Error exporting widget ${widget.id} to Excel:`, error);
          // Continue with next widget
        }
      }

      // Save the workbook
      XLSX.writeFile(workbook, filename);
      console.log(`Excel file saved as: ${filename}`);

    } catch (error) {
      console.error('Error exporting dashboard to Excel:', error);
      throw new Error('Failed to export dashboard to Excel');
    }
  }

  /**
   * Export a single widget to a sheet
   */
  private async exportWidgetToSheet(
    workbook: XLSX.WorkBook,
    widget: IWidget,
    options: {
      includeHeaders: boolean;
      sheetNamePrefix: string;
      autoColumnWidth: boolean;
      includeWidgetTitles: boolean;
    }
  ): Promise<void> {
    const { includeHeaders, sheetNamePrefix, autoColumnWidth, includeWidgetTitles } = options;

    // Extract data from widget based on its type
    const dataExtractor = this.getDataExtractor(widget);
    if (!dataExtractor) {
      console.warn(`No data extractor found for widget type: ${widget.config?.component}`);
      return;
    }

    const data = dataExtractor.extractData(widget);
    const headers = dataExtractor.getHeaders(widget);
    const sheetName = dataExtractor.getSheetName(widget);

    if (!data || data.length === 0) {
      console.warn(`No data found for widget: ${widget.id}`);
      return;
    }

    console.log(`Exporting widget ${widget.id} (${sheetName}) with ${data.length} rows`);

    // Prepare worksheet data
    let worksheetData: any[] = [];

    // Add widget title if requested
    if (includeWidgetTitles && widget.config?.header?.title) {
      worksheetData.push([widget.config.header.title]);
      worksheetData.push([]); // Empty row
    }

    // Add headers if requested
    if (includeHeaders && headers.length > 0) {
      worksheetData.push(headers);
    }

    // Add data rows
    worksheetData = worksheetData.concat(data);

    // Create worksheet
    const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

    // Auto-resize columns if requested
    if (autoColumnWidth) {
      this.autoResizeColumns(worksheet, worksheetData);
    }

    // Add worksheet to workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);

    console.log(`Widget ${widget.id} exported to sheet: ${sheetName}`);
  }

  /**
   * Add timestamp sheet to workbook
   */
  private addTimestampSheet(workbook: XLSX.WorkBook): void {
    const timestamp = new Date().toLocaleString();
    const timestampData = [
      ['Dashboard Export Information'],
      [],
      ['Export Date:', timestamp],
      ['Generated by:', 'MoneyPlant Dashboard'],
      ['Version:', '1.0.0']
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(timestampData);
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Export Info');
  }

  /**
   * Auto-resize columns based on content
   */
  private autoResizeColumns(worksheet: XLSX.WorkSheet, data: any[]): void {
    const columnWidths: { [key: string]: number } = {};

    // Calculate maximum width for each column
    data.forEach(row => {
      if (Array.isArray(row)) {
        row.forEach((cell, index) => {
          const columnKey = XLSX.utils.encode_col(index);
          const cellLength = cell ? cell.toString().length : 0;
          columnWidths[columnKey] = Math.max(columnWidths[columnKey] || 0, cellLength);
        });
      }
    });

    // Set column widths (with some padding)
    worksheet['!cols'] = Object.keys(columnWidths).map(key => ({
      wch: Math.min(Math.max(columnWidths[key] + 2, 10), 50) // Min 10, Max 50
    }));
  }

  /**
   * Get data extractor for widget type
   */
  private getDataExtractor(widget: IWidget): WidgetDataExtractor | null {
    const component = widget.config?.component;
    const chartType = (widget.config?.options as any)?.series?.[0]?.type;

    // For echart widgets, use the appropriate chart builder
    if (component === 'echart') {
      return this.getChartDataExtractor(chartType);
    }
    
    // For other widget types, use generic extractors
    switch (component) {
      case 'table':
        return this.getTableDataExtractor();
      case 'tile':
        return this.getTileDataExtractor();
      default:
        return this.getGenericDataExtractor();
    }
  }

  /**
   * Get chart data extractor based on chart type using chart builders
   */
  private getChartDataExtractor(chartType: string): WidgetDataExtractor {
    switch (chartType) {
      case 'pie':
        return {
          extractData: (widget: IWidget) => PieChartBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => PieChartBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => PieChartBuilder.create().getExportSheetName(widget)
        };
      case 'bar':
        return {
          extractData: (widget: IWidget) => BarChartBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => BarChartBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => BarChartBuilder.create().getExportSheetName(widget)
        };
      case 'line':
        return {
          extractData: (widget: IWidget) => LineChartBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => LineChartBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => LineChartBuilder.create().getExportSheetName(widget)
        };
      case 'scatter':
        return {
          extractData: (widget: IWidget) => ScatterChartBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => ScatterChartBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => ScatterChartBuilder.create().getExportSheetName(widget)
        };
      case 'gauge':
        return {
          extractData: (widget: IWidget) => GaugeChartBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => GaugeChartBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => GaugeChartBuilder.create().getExportSheetName(widget)
        };
      case 'heatmap':
        return {
          extractData: (widget: IWidget) => HeatmapChartBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => HeatmapChartBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => HeatmapChartBuilder.create().getExportSheetName(widget)
        };
      case 'map':
        return {
          extractData: (widget: IWidget) => DensityMapBuilder.create().exportData(widget),
          getHeaders: (widget: IWidget) => DensityMapBuilder.create().getExportHeaders(widget),
          getSheetName: (widget: IWidget) => DensityMapBuilder.create().getExportSheetName(widget)
        };
      default:
        return {
          extractData: (widget: IWidget) => this.extractGenericChartData(widget),
          getHeaders: () => ['Data Point', 'Value'],
          getSheetName: (widget: IWidget) => this.getWidgetSheetName(widget, 'Chart')
        };
    }
  }

  /**
   * Get table data extractor
   */
  private getTableDataExtractor(): WidgetDataExtractor {
    return {
      extractData: (widget: IWidget) => this.extractTableData(widget),
      getHeaders: (widget: IWidget) => this.extractTableHeaders(widget),
      getSheetName: (widget: IWidget) => this.getWidgetSheetName(widget, 'Table')
    };
  }

  /**
   * Get tile data extractor
   */
  private getTileDataExtractor(): WidgetDataExtractor {
    return {
      extractData: (widget: IWidget) => this.extractTileData(widget),
      getHeaders: () => ['Metric', 'Value', 'Change', 'Percentage'],
      getSheetName: (widget: IWidget) => this.getWidgetSheetName(widget, 'Tile')
    };
  }

  /**
   * Get generic data extractor
   */
  private getGenericDataExtractor(): WidgetDataExtractor {
    return {
      extractData: (widget: IWidget) => this.extractGenericData(widget),
      getHeaders: () => ['Property', 'Value'],
      getSheetName: (widget: IWidget) => this.getWidgetSheetName(widget, 'Data')
    };
  }

  /**
   * Extract table data
   */
  private extractTableData(widget: IWidget): any[] {
    const tableOptions = widget.config?.options as any;
    const tableData = tableOptions?.data;
    if (!tableData || !Array.isArray(tableData)) return [];

    return tableData;
  }

  /**
   * Extract table headers
   */
  private extractTableHeaders(widget: IWidget): string[] {
    const tableOptions = widget.config?.options as any;
    const columns = tableOptions?.columns;
    if (!columns || !Array.isArray(columns)) return [];

    return columns.map((col: any) => col.title || col.field || 'Column');
  }

  /**
   * Extract tile data
   */
  private extractTileData(widget: IWidget): any[] {
    const tileOptions = widget.config?.options as any;
    const tileData = tileOptions?.data;
    if (!tileData) return [];

    return [[
      widget.config?.header?.title || 'Metric',
      tileData.value || 0,
      tileData.change || 0,
      tileData.percentage || 0
    ]];
  }

  /**
   * Extract generic chart data
   */
  private extractGenericChartData(widget: IWidget): any[] {
    const series = (widget.config?.options as any)?.series?.[0];
    if (!series?.data) return [];

    return series.data.map((item: any, index: number) => [
      `Data Point ${index + 1}`,
      item.value || item || 0
    ]);
  }

  /**
   * Extract generic data
   */
  private extractGenericData(widget: IWidget): any[] {
    const widgetOptions = widget.config?.options as any;
    const data = widgetOptions?.data;
    if (!data) return [];

    if (Array.isArray(data)) {
      return data.map((item, index) => [`Item ${index + 1}`, item]);
    } else if (typeof data === 'object') {
      return Object.entries(data).map(([key, value]) => [key, value]);
    } else {
      return [['Value', data]];
    }
  }

  /**
   * Get widget sheet name
   */
  private getWidgetSheetName(widget: IWidget, type: string): string {
    const title = widget.config?.header?.title || widget.id;
    const cleanTitle = title.replace(/[^\w\s]/gi, '').substring(0, 20);
    return `${cleanTitle} (${type})`;
  }

  /**
   * Export single widget to Excel
   */
  async exportWidgetToExcel(
    widget: IWidget,
    options: ExcelExportOptions = {}
  ): Promise<void> {
    const {
      filename = `widget-${widget.id}-${new Date().toISOString().split('T')[0]}.xlsx`,
      includeHeaders = true,
      includeTimestamp = false,
      sheetNamePrefix = 'Widget',
      autoColumnWidth = true,
      includeWidgetTitles = true
    } = options;

    try {
      console.log(`Exporting single widget ${widget.id} to Excel`);

      // Create a new workbook
      const workbook = XLSX.utils.book_new();

      // Add timestamp sheet if requested
      if (includeTimestamp) {
        this.addTimestampSheet(workbook);
      }

      // Export widget to sheet
      await this.exportWidgetToSheet(workbook, widget, {
        includeHeaders,
        sheetNamePrefix,
        autoColumnWidth,
        includeWidgetTitles
      });

      // Save the workbook
      XLSX.writeFile(workbook, filename);
      console.log(`Excel file saved as: ${filename}`);

    } catch (error) {
      console.error('Error exporting widget to Excel:', error);
      throw new Error('Failed to export widget to Excel');
    }
  }
} 